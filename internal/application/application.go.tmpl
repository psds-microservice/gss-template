package application

import (
	"context"
	"fmt"
	"log"
	"net"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"syscall"
	"time"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"{{.Group}}/{{.Project.K}}/internal/config"
	"{{.Group}}/{{.Project.K}}/internal/database"
	grpcserver "{{.Group}}/{{.Project.K}}/internal/grpc"
	"{{.Group}}/{{.Project.K}}/internal/handler"
	"{{.Group}}/{{.Project.K}}/internal/model"
	"{{.Group}}/{{.Project.K}}/pkg/constants"
	"{{.Group}}/{{.Project.K}}/pkg/gen/proto"

	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
	"gorm.io/gorm"
	httpSwagger "github.com/swaggo/http-swagger"
)

const (
	TypeApi       = "api"
	TypeWorker    = "worker"
	TypeScheduler = "scheduler"
	TypeCommand   = "command"
	TypeSeeder    = "seeder"
)

// serveOpenAPISpec отдаёт api/openapi.json или api/openapi.swagger.json (при наличии). Для генерации из proto: make proto-openapi.
func serveOpenAPISpec() http.HandlerFunc {
	return func(w http.ResponseWriter, _ *http.Request) {
		for _, path := range []string{"api/openapi.swagger.json", "api/openapi.json", "api/api.swagger.json", "openapi.json"} {
			data, err := os.ReadFile(path)
			if err == nil {
				w.Header().Set("Content-Type", "application/json")
				w.Write(data)
				return
			}
		}
		exe, _ := os.Executable()
		if exe != "" {
			dir := filepath.Dir(exe)
			for _, name := range []string{"openapi.swagger.json", "openapi.json", "api.swagger.json"} {
				data, err := os.ReadFile(filepath.Join(dir, "api", name))
				if err == nil {
					w.Header().Set("Content-Type", "application/json")
					w.Write(data)
					return
				}
			}
		}
		http.Error(w, "openapi.json not found. Put spec in api/ or run: make proto-openapi", http.StatusNotFound)
	}
}

// Application — фабрика по режиму: api, worker, scheduler, command, seeder.
type Application struct {
	Cfg       *config.Config
	DB        *gorm.DB
	Srv       *http.Server
	GrpcSrv   *grpc.Server
	grpcLis   net.Listener
}

// New создаёт приложение для указанного режима.
func New(mode string) (*Application, error) {
	cfg, err := config.Load()
	if err != nil {
		return nil, err
	}
	if err := cfg.Validate(); err != nil {
		return nil, err
	}

	app := &Application{Cfg: cfg}

	switch mode {
	case TypeApi, TypeCommand, TypeSeeder:
		db, err := database.Open(cfg.DSN())
		if err != nil {
			return nil, err
		}
		app.DB = db
		// SQL-миграции из database/migrations (golang-migrate)
		if mode == TypeApi {
			if err := database.MigrateUp(cfg.DatabaseURL()); err != nil {
				return nil, err
			}
		}
		if err := db.AutoMigrate(&model.User{}); err != nil {
			return nil, err
		}
	}

	if mode == TypeApi {
		grpcAddr := cfg.AppHost + ":" + cfg.GRPCPort()
		lis, err := net.Listen("tcp", grpcAddr)
		if err != nil {
			return nil, fmt.Errorf("grpc listen %s: %w", grpcAddr, err)
		}
		app.grpcLis = lis
		grpcSrv := grpc.NewServer()
		gwImpl := grpcserver.NewServer(grpcserver.Deps{})
		proto.RegisterApiServiceServer(grpcSrv, gwImpl)
		reflection.Register(grpcSrv)
		app.GrpcSrv = grpcSrv

		gatewayMux := runtime.NewServeMux()
		if err := proto.RegisterApiServiceHandlerServer(context.Background(), gatewayMux, gwImpl); err != nil {
			return nil, fmt.Errorf("register grpc-gateway: %w", err)
		}

		mux := http.NewServeMux()
		mux.HandleFunc(constants.PathHealth, handler.Health)
		mux.HandleFunc(constants.PathReady, handler.Ready)
		mux.HandleFunc(constants.PathSwagger+"/openapi.json", serveOpenAPISpec())
		mux.Handle(constants.PathSwagger+"/", httpSwagger.Handler(
			httpSwagger.URL("openapi.json"),
			httpSwagger.DeepLinking(true),
			httpSwagger.DocExpansion("list"),
		))
		mux.Handle("/", gatewayMux)
		app.Srv = &http.Server{
			Addr:              cfg.AppHost + ":" + cfg.HTTPPort(),
			Handler:           mux,
			ReadHeaderTimeout: 5 * time.Second,
			ReadTimeout:       15 * time.Second,
			WriteTimeout:      30 * time.Second,
			IdleTimeout:       60 * time.Second,
		}
	}

	return app, nil
}

// Run запускает HTTP (и grpc-gateway) и gRPC серверы (режим api).
func (a *Application) Run() {
	if a.Srv == nil {
		log.Fatal("application: Run only for api mode")
	}
	go func() {
		if err := a.Srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Printf("http: %v", err)
		}
	}()
	go func() {
		if err := a.GrpcSrv.Serve(a.grpcLis); err != nil {
			log.Printf("grpc: %v", err)
		}
	}()
	log.Printf("HTTP (grpc-gateway): %s", a.Srv.Addr)
	log.Printf("gRPC: %s", a.grpcLis.Addr().String())
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
	<-quit
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	if err := a.Srv.Shutdown(ctx); err != nil {
		log.Printf("http shutdown: %v", err)
	}
	a.GrpcSrv.GracefulStop()
}

// RunMigrations применяет SQL-миграции из database/migrations (golang-migrate).
func (a *Application) RunMigrations() error {
	if a.Cfg == nil {
		return fmt.Errorf("application: config not initialized")
	}
	return database.MigrateUp(a.Cfg.DatabaseURL())
}

// CreateMigration создаёт пару файлов миграции в database/migrations (golang-migrate: .up.sql, .down.sql).
func (a *Application) CreateMigration(name string) error {
	dir := "database/migrations"
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}
	// Используем timestamp для порядка: 000001_name.up.sql / .down.sql
	base := fmt.Sprintf("%d_%s", time.Now().Unix(), name)
	upPath := filepath.Join(dir, base+".up.sql")
	downPath := filepath.Join(dir, base+".down.sql")
	if err := os.WriteFile(upPath, []byte("-- migration up: "+name+"\n"), 0644); err != nil {
		return err
	}
	return os.WriteFile(downPath, []byte("-- migration down: "+name+"\n"), 0644)
}

// RunWorker запускает воркер очередей (заглушка: добавьте RabbitMQ consumer).
func (a *Application) RunWorker() {
	log.Println("worker: stub — add internal/consumer and message queue")
	select {}
}

// RunScheduler запускает планировщик (заглушка: добавьте cron/periodic jobs).
func (a *Application) RunScheduler() {
	log.Println("scheduler: stub — add internal/scheduler and jobs")
	select {}
}

// RunSeeder применяет миграции и сиды из database/seeds (SQL-файлы по порядку).
func (a *Application) RunSeeder() {
	if a.Cfg == nil || a.DB == nil {
		log.Fatal("seeder: config or DB not initialized")
	}
	if err := database.MigrateUp(a.Cfg.DatabaseURL()); err != nil {
		log.Fatalf("seeder: migrate: %v", err)
	}
	if err := database.RunSeeds(a.DB); err != nil {
		log.Fatalf("seeder: %v", err)
	}
	log.Println("seeder: done")
}
