// Code generated by gss-template stub. Run "make proto" to generate real code from pkg/proto/*.proto.
package proto

import (
	"context"

	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"google.golang.org/grpc"
)

// ApiServiceServer — интерфейс сервиса (заглушка до make proto).
type ApiServiceServer interface {
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
}

// UnimplementedApiServiceServer — встраивайте в реализацию для обратной совместимости.
type UnimplementedApiServiceServer struct{}

func (UnimplementedApiServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, nil
}

// RegisterApiServiceServer регистрирует gRPC-сервер.
func RegisterApiServiceServer(s grpc.ServiceRegistrar, srv ApiServiceServer) {
	s.RegisterService(&ApiService_ServiceDesc, srv)
}

// RegisterApiServiceHandlerServer регистрирует grpc-gateway (заглушка; после make proto подставится реальная реализация).
func RegisterApiServiceHandlerServer(ctx context.Context, mux *runtime.ServeMux, server ApiServiceServer) error {
	return nil
}

// ApiService_ServiceDesc — дескриптор сервиса для регистрации.
var ApiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.ApiService",
	HandlerType: (*ApiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Health",
			Handler:    _ApiService_Health_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func _ApiService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{Server: srv, FullMethod: "/api.ApiService/Health"}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}
